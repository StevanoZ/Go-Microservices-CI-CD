// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: user.sql

package user_db

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const createUser = `-- name: CreateUser :one
INSERT INTO "user"(id, email, username, password, otp_code)
VALUES($1, $2, $3, $4, $5) RETURNING id, email, username, password, attempt_left, otp_code, phone_number, status, main_image_url, created_at, updated_at, main_image_path
`

type CreateUserParams struct {
	ID       uuid.UUID `json:"id"`
	Email    string    `json:"email"`
	Username string    `json:"username"`
	Password string    `json:"password"`
	OtpCode  int64     `json:"otp_code"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.Username,
		arg.Password,
		arg.OtpCode,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.AttemptLeft,
		&i.OtpCode,
		&i.PhoneNumber,
		&i.Status,
		&i.MainImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainImagePath,
	)
	return i, err
}

const createUserImage = `-- name: CreateUserImage :one
INSERT INTO "user_image"(id, image_url, image_path, user_id, is_main) 
VALUES($1, $2, $3, $4, $5) 
RETURNING id, image_url, is_main, user_id, created_at, updated_at, image_path
`

type CreateUserImageParams struct {
	ID        uuid.UUID `json:"id"`
	ImageUrl  string    `json:"image_url"`
	ImagePath string    `json:"image_path"`
	UserID    uuid.UUID `json:"user_id"`
	IsMain    bool      `json:"is_main"`
}

func (q *Queries) CreateUserImage(ctx context.Context, arg CreateUserImageParams) (UserImage, error) {
	row := q.db.QueryRowContext(ctx, createUserImage,
		arg.ID,
		arg.ImageUrl,
		arg.ImagePath,
		arg.UserID,
		arg.IsMain,
	)
	var i UserImage
	err := row.Scan(
		&i.ID,
		&i.ImageUrl,
		&i.IsMain,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImagePath,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM "user" WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const deleteUserImage = `-- name: DeleteUserImage :exec
DELETE FROM "user_image" WHERE id = $1
`

func (q *Queries) DeleteUserImage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUserImage, id)
	return err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, email, username, password, attempt_left, otp_code, phone_number, status, main_image_url, created_at, updated_at, main_image_path FROM "user" WHERE email = $1 LIMIT 1
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.AttemptLeft,
		&i.OtpCode,
		&i.PhoneNumber,
		&i.Status,
		&i.MainImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainImagePath,
	)
	return i, err
}

const findUserById = `-- name: FindUserById :one
SELECT id, email, username, password, attempt_left, otp_code, phone_number, status, main_image_url, created_at, updated_at, main_image_path FROM "user" WHERE id = $1 LIMIT 1
`

func (q *Queries) FindUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.AttemptLeft,
		&i.OtpCode,
		&i.PhoneNumber,
		&i.Status,
		&i.MainImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainImagePath,
	)
	return i, err
}

const findUserImageById = `-- name: FindUserImageById :one
SELECT id, image_url, is_main, user_id, created_at, updated_at, image_path FROM "user_image" WHERE id = $1
`

func (q *Queries) FindUserImageById(ctx context.Context, id uuid.UUID) (UserImage, error) {
	row := q.db.QueryRowContext(ctx, findUserImageById, id)
	var i UserImage
	err := row.Scan(
		&i.ID,
		&i.ImageUrl,
		&i.IsMain,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImagePath,
	)
	return i, err
}

const findUserImagesByUserId = `-- name: FindUserImagesByUserId :many
SELECT id, image_url, is_main, user_id, created_at, updated_at, image_path FROM "user_image" WHERE user_id = $1
`

func (q *Queries) FindUserImagesByUserId(ctx context.Context, userID uuid.UUID) ([]UserImage, error) {
	rows, err := q.db.QueryContext(ctx, findUserImagesByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserImage{}
	for rows.Next() {
		var i UserImage
		if err := rows.Scan(
			&i.ID,
			&i.ImageUrl,
			&i.IsMain,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserWithImages = `-- name: FindUserWithImages :one
SELECT u.id, u.email, u.username, u.password, u.attempt_left, u.otp_code, u.phone_number, u.status, u.main_image_url, u.created_at, u.updated_at, u.main_image_path, array_to_json(array_agg(row_to_json(ui.*))) as images FROM "user" as u LEFT JOIN "user_image" as ui 
ON ui.user_id = u.id WHERE u.id = $1
GROUP BY u.id
`

type FindUserWithImagesRow struct {
	ID            uuid.UUID       `json:"id"`
	Email         string          `json:"email"`
	Username      string          `json:"username"`
	Password      string          `json:"password"`
	AttemptLeft   int32           `json:"attempt_left"`
	OtpCode       int64           `json:"otp_code"`
	PhoneNumber   string          `json:"phone_number"`
	Status        string          `json:"status"`
	MainImageUrl  string          `json:"main_image_url"`
	CreatedAt     time.Time       `json:"created_at"`
	UpdatedAt     time.Time       `json:"updated_at"`
	MainImagePath string          `json:"main_image_path"`
	Images        json.RawMessage `json:"images"`
}

func (q *Queries) FindUserWithImages(ctx context.Context, id uuid.UUID) (FindUserWithImagesRow, error) {
	row := q.db.QueryRowContext(ctx, findUserWithImages, id)
	var i FindUserWithImagesRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.AttemptLeft,
		&i.OtpCode,
		&i.PhoneNumber,
		&i.Status,
		&i.MainImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainImagePath,
		&i.Images,
	)
	return i, err
}

const findUsers = `-- name: FindUsers :many
SELECT id, email, username, password, attempt_left, otp_code, phone_number, status, main_image_url, created_at, updated_at, main_image_path FROM "user" WHERE 
CASE 
WHEN $3::text = 'username' THEN username 
WHEN $3::text = 'email' THEN email
ELSE username END ILIKE
CASE
WHEN $3::text = '' THEN '%%'
ELSE $4 END
AND status = CASE 
WHEN $5::text = '' THEN 'active'
ELSE $5 END 
ORDER BY 
CASE WHEN $6::text = 'email' THEN email END ASC,
CASE WHEN $6::text = '-email' THEN email END DESC,
CASE WHEN $6::text = 'username' THEN username END ASC,
CASE WHEN $6::text = '-username' THEN username END DESC,
CASE WHEN $6::text = 'createdAt' THEN created_at END ASC,
CASE WHEN $6::text = '-createdAt' THEN created_at END DESC, 
CASE WHEN $6::text = '' THEN username END ASC
LIMIT $1 OFFSET $2
`

type FindUsersParams struct {
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
	SearchField string `json:"search_field"`
	SearchValue string `json:"search_value"`
	FilterBy    string `json:"filter_by"`
	SortBy      string `json:"sort_by"`
}

func (q *Queries) FindUsers(ctx context.Context, arg FindUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, findUsers,
		arg.Limit,
		arg.Offset,
		arg.SearchField,
		arg.SearchValue,
		arg.FilterBy,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.AttemptLeft,
			&i.OtpCode,
			&i.PhoneNumber,
			&i.Status,
			&i.MainImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MainImagePath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPaginationCount = `-- name: GetUsersPaginationCount :one
SELECT COUNT(*) FROM "user" WHERE
CASE 
WHEN $1::text = 'username' THEN username 
WHEN $1::text = 'email' THEN email
ELSE username END ILIKE
CASE
WHEN $1::text = '' THEN '%%'
ELSE $2 END
AND status = CASE 
WHEN $3::text = '' THEN 'active'
ELSE $3 END
`

type GetUsersPaginationCountParams struct {
	SearchField string `json:"search_field"`
	SearchValue string `json:"search_value"`
	FilterBy    string `json:"filter_by"`
}

func (q *Queries) GetUsersPaginationCount(ctx context.Context, arg GetUsersPaginationCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUsersPaginationCount, arg.SearchField, arg.SearchValue, arg.FilterBy)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE "user" SET username = $1, password = $2, phone_number = $3, 
attempt_left = $4, otp_code = $5, status = $6, 
updated_at = now() WHERE id = $7 RETURNING id, email, username, password, attempt_left, otp_code, phone_number, status, main_image_url, created_at, updated_at, main_image_path
`

type UpdateUserParams struct {
	Username    string    `json:"username"`
	Password    string    `json:"password"`
	PhoneNumber string    `json:"phone_number"`
	AttemptLeft int32     `json:"attempt_left"`
	OtpCode     int64     `json:"otp_code"`
	Status      string    `json:"status"`
	ID          uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Username,
		arg.Password,
		arg.PhoneNumber,
		arg.AttemptLeft,
		arg.OtpCode,
		arg.Status,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.AttemptLeft,
		&i.OtpCode,
		&i.PhoneNumber,
		&i.Status,
		&i.MainImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainImagePath,
	)
	return i, err
}

const updateUserImage = `-- name: UpdateUserImage :one
UPDATE "user_image" SET is_main = $1, updated_at = now() WHERE id = $2 RETURNING id, image_url, is_main, user_id, created_at, updated_at, image_path
`

type UpdateUserImageParams struct {
	IsMain bool      `json:"is_main"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserImage(ctx context.Context, arg UpdateUserImageParams) (UserImage, error) {
	row := q.db.QueryRowContext(ctx, updateUserImage, arg.IsMain, arg.ID)
	var i UserImage
	err := row.Scan(
		&i.ID,
		&i.ImageUrl,
		&i.IsMain,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ImagePath,
	)
	return i, err
}

const updateUserMainImage = `-- name: UpdateUserMainImage :one
UPDATE "user" SET main_image_url = $1, main_image_path = $2 
WHERE id = $3 RETURNING id, email, username, password, attempt_left, otp_code, phone_number, status, main_image_url, created_at, updated_at, main_image_path
`

type UpdateUserMainImageParams struct {
	MainImageUrl  string    `json:"main_image_url"`
	MainImagePath string    `json:"main_image_path"`
	ID            uuid.UUID `json:"id"`
}

func (q *Queries) UpdateUserMainImage(ctx context.Context, arg UpdateUserMainImageParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUserMainImage, arg.MainImageUrl, arg.MainImagePath, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.AttemptLeft,
		&i.OtpCode,
		&i.PhoneNumber,
		&i.Status,
		&i.MainImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.MainImagePath,
	)
	return i, err
}
